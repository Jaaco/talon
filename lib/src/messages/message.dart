import 'dart:convert';

/// A single data change in the Talon sync system.
///
/// Each [Message] represents one field-level change to your data.
/// Messages are the fundamental unit of synchronization in Talon.
///
/// ## Structure
///
/// A message captures:
/// - **What changed**: [table], [row], [column], [value]
/// - **Who changed it**: [userId], [clientId]
/// - **When it changed**: [localTimestamp] (HLC), [serverTimestamp]
/// - **Sync status**: [hasBeenSynced], [hasBeenApplied]
///
/// ## Example
///
/// When you call `talon.saveChange()`, a Message is created:
/// ```dart
/// // This creates a Message internally:
/// await talon.saveChange(
///   table: 'todos',
///   row: 'todo-123',
///   column: 'name',
///   value: 'Buy milk',
/// );
/// ```
///
/// ## Conflict Resolution
///
/// Messages use Hybrid Logical Clock (HLC) timestamps stored in
/// [localTimestamp]. When the same cell (table/row/column) is modified
/// on multiple devices, the message with the latest HLC wins.
///
/// ## Serialization
///
/// Use [toMap]/[fromMap] or [toJson]/[fromJson] for database storage:
/// ```dart
/// // Store in database
/// await db.insert('messages', message.toMap());
///
/// // Load from database
/// final message = Message.fromMap(row);
/// ```
class Message {
  /// Unique identifier for this message.
  ///
  /// Generated by the [Talon.createNewIdFunction] when the change is made.
  /// Typically a UUID v4.
  final String id;

  /// The database table this change applies to.
  ///
  /// Example: `'todos'`, `'users'`, `'settings'`
  final String table;

  /// The row identifier (primary key) within the table.
  ///
  /// Example: `'todo-123'`, `'user-456'`
  final String row;

  /// The column/field name that was changed.
  ///
  /// Example: `'name'`, `'is_done'`, `'updated_at'`
  final String column;

  /// The data type of the value for deserialization.
  ///
  /// Supported types: `'string'`, `'int'`, `'double'`, `'bool'`,
  /// `'datetime'`, `'json'`, `'null'`
  ///
  /// Use [typedValue] to get the deserialized value.
  final String dataType;

  /// The serialized string value of the change.
  ///
  /// All values are stored as strings. Use [typedValue] to get
  /// the properly typed value based on [dataType].
  final String value;

  /// Server-assigned timestamp for ordering and sync tracking.
  ///
  /// Set by the server when the message is received.
  /// Used for incremental sync (only fetch messages after this timestamp).
  /// Null for messages that haven't been synced yet.
  final int? serverTimestamp;

  /// Hybrid Logical Clock timestamp for conflict resolution.
  ///
  /// Format: `{timestamp}:{count}:{node}`
  /// - timestamp: Wall clock time in milliseconds
  /// - count: Logical counter for same-millisecond ordering
  /// - node: Client ID that created this message
  ///
  /// This timestamp is used for last-write-wins conflict resolution.
  final String localTimestamp;

  /// The ID of the user who made this change.
  final String userId;

  /// The ID of the client/device that made this change.
  ///
  /// Used to filter out own messages when receiving from the server.
  final String clientId;

  /// Whether this message has been applied to the local data table.
  ///
  /// A message might be stored but not applied if it lost
  /// conflict resolution to a newer message.
  final bool hasBeenApplied;

  /// Whether this message has been successfully synced to the server.
  ///
  /// Messages with `hasBeenSynced = false` are queued for upload.
  final bool hasBeenSynced;

  /// Creates a new [Message].
  ///
  /// In most cases, you won't create messages directly.
  /// Use [Talon.saveChange] instead.
  Message({
    required this.id,
    required this.table,
    required this.row,
    required this.column,
    required this.dataType,
    required this.value,
    this.serverTimestamp,
    required this.localTimestamp,
    required this.userId,
    required this.clientId,
    required this.hasBeenApplied,
    required this.hasBeenSynced,
  });

  /// Creates a copy of this message with the given fields replaced.
  ///
  /// Useful for updating sync status without modifying the original:
  /// ```dart
  /// final synced = message.copyWith(hasBeenSynced: true);
  /// ```
  Message copyWith({
    String? id,
    String? table,
    String? row,
    String? column,
    String? dataType,
    String? value,
    int? serverTimestamp,
    String? localTimestamp,
    String? userId,
    String? clientId,
    bool? hasBeenApplied,
    bool? hasBeenSynced,
  }) {
    return Message(
      id: id ?? this.id,
      table: table ?? this.table,
      row: row ?? this.row,
      column: column ?? this.column,
      dataType: dataType ?? this.dataType,
      value: value ?? this.value,
      serverTimestamp: serverTimestamp ?? this.serverTimestamp,
      localTimestamp: localTimestamp ?? this.localTimestamp,
      userId: userId ?? this.userId,
      clientId: clientId ?? this.clientId,
      hasBeenApplied: hasBeenApplied ?? this.hasBeenApplied,
      hasBeenSynced: hasBeenSynced ?? this.hasBeenSynced,
    );
  }

  /// Converts this message to a Map for database storage.
  ///
  /// The keys match the column names in [TalonSchema.messagesTableSql]:
  /// - `table_name` (not `table` to avoid SQL reserved word conflicts)
  /// - Boolean fields are stored as integers (0 or 1)
  ///
  /// Example:
  /// ```dart
  /// await db.insert('messages', message.toMap());
  /// ```
  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'id': id,
      'table_name': table,
      'row': row,
      'column': column,
      'data_type': dataType,
      'value': value,
      'server_timestamp': serverTimestamp,
      'local_timestamp': localTimestamp,
      'user_id': userId,
      'client_id': clientId,
      'hasBeenApplied': hasBeenApplied ? 1 : 0,
      'hasBeenSynced': hasBeenSynced ? 1 : 0,
    };
  }

  /// Creates a Message from a database row Map.
  ///
  /// The map keys should match those produced by [toMap].
  ///
  /// Example:
  /// ```dart
  /// final rows = await db.query('messages');
  /// final messages = rows.map((row) => Message.fromMap(row)).toList();
  /// ```
  factory Message.fromMap(Map<String, dynamic> map) {
    return Message(
      id: map['id'] as String,
      table: map['table_name'] as String,
      row: map['row'] as String,
      column: map['column'] as String,
      dataType: map['data_type'] as String,
      value: map['value'] as String,
      serverTimestamp: map['server_timestamp'] != null
          ? map['server_timestamp'] as int
          : null,
      localTimestamp: map['local_timestamp'] as String,
      userId: map['user_id'] as String,
      clientId: map['client_id'] as String,
      hasBeenApplied: map['hasBeenApplied'] == 1 ? true : false,
      hasBeenSynced: map['hasBeenSynced'] == 1 ? true : false,
    );
  }

  /// Converts this message to a JSON string.
  ///
  /// Useful for network transmission or debugging.
  String toJson() => json.encode(toMap());

  /// Creates a Message from a JSON string.
  ///
  /// The JSON should contain the same keys as [toMap].
  factory Message.fromJson(String source) =>
      Message.fromMap(json.decode(source) as Map<String, dynamic>);

  @override
  String toString() {
    return 'Message(id: $id, table: $table, row: $row, column: $column, '
        'dataType: $dataType, value: $value, serverTimestamp: $serverTimestamp, '
        'localTimestamp: $localTimestamp, userId: $userId, clientId: $clientId, '
        'hasBeenApplied: $hasBeenApplied, hasBeenSynced: $hasBeenSynced)';
  }

  @override
  bool operator ==(covariant Message other) {
    if (identical(this, other)) return true;

    return other.id == id &&
        other.table == table &&
        other.row == row &&
        other.column == column &&
        other.dataType == dataType &&
        other.value == value &&
        other.serverTimestamp == serverTimestamp &&
        other.localTimestamp == localTimestamp &&
        other.userId == userId &&
        other.clientId == clientId &&
        other.hasBeenApplied == hasBeenApplied &&
        other.hasBeenSynced == hasBeenSynced;
  }

  @override
  int get hashCode {
    return id.hashCode ^
        table.hashCode ^
        row.hashCode ^
        column.hashCode ^
        dataType.hashCode ^
        value.hashCode ^
        serverTimestamp.hashCode ^
        localTimestamp.hashCode ^
        userId.hashCode ^
        clientId.hashCode ^
        hasBeenApplied.hashCode ^
        hasBeenSynced.hashCode;
  }

  /// Returns the deserialized value based on [dataType].
  ///
  /// Converts the string [value] back to its original type:
  /// - `'null'` → `null`
  /// - `'string'` → `String`
  /// - `'int'` → `int`
  /// - `'double'` → `double`
  /// - `'bool'` → `bool` (from `'1'`/`'0'` or `'true'`/`'false'`)
  /// - `'datetime'` → `DateTime` (from ISO 8601 string)
  /// - `'json'` → `Map` or `List` (decoded from JSON string)
  ///
  /// Example:
  /// ```dart
  /// final message = Message(..., dataType: 'int', value: '42');
  /// final count = message.typedValue as int; // 42
  /// ```
  ///
  /// Note: This is a convenience method for reading values.
  /// The actual database storage/retrieval is your responsibility.
  dynamic get typedValue {
    switch (dataType) {
      case 'null':
        return null;
      case '':
        if (value.isEmpty) return null;
        return value;
      case 'string':
        return value;
      case 'int':
        return int.tryParse(value) ?? 0;
      case 'double':
        return double.tryParse(value) ?? 0.0;
      case 'bool':
        return value == '1' || value.toLowerCase() == 'true';
      case 'datetime':
        return DateTime.tryParse(value);
      case 'json':
        try {
          return json.decode(value);
        } catch (e) {
          return value;
        }
      default:
        return value;
    }
  }
}
